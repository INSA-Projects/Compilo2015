/*
 *     Projet Compilateur Yaka 2015
 *
 */


PARSER_BEGIN(Yaka)

public class Yaka {
  public static Declaration declaration;
  public static TabIdent tabIdent;
  public static Expression expression;
  public static YVM yvm;
 
  public static void main(String args[]) { 
    Yaka analyseur;
    //evaluator = new Evaluator();
    //generator = new YVMGenerator();
    java.io.InputStream input;

    if (args.length==1) {
      System.out.print(args[args.length-1] + ": ");
      try {
        input = new java.io.FileInputStream(args[args.length-1]);
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Fichier introuvable.");
        return;
      }
    } else if (args.length==0) {
      System.out.println("Lecture sur l'entree standard...");
      input = System.in;
    } else {
      System.out.println("Usage: java Yaka[fichier]");
      return;
    }
    try {
      analyseur = new Yaka(input);
      analyseur.prog();
      System.out.println("Successfull analysis !");
    } catch (ParseException e) {
      String msg = e.getMessage();
      msg = msg.substring(0,msg.indexOf("\n"));
      System.out.println("Erreur de syntaxe : "+msg);
    }
  } 
}

PARSER_END(Yaka)
/***************************************/
/********** TOKEN DEFINITIONS **********/
/***************************************/

TOKEN_MGR_DECLS :
{public static String identLu,chaineLue;
 public static int entierLu;}

/*** Skip whitespace and comments ***/
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "(*"   : IN_COMMENT
}
<IN_COMMENT> MORE:
{
  < ~[] >
}
<IN_COMMENT> SKIP:
{
   < "*)" >  {SwitchTo(DEFAULT);} 
}



/*** unites de base nombres, idents,  strings ***/
TOKEN  :
{
  < #chiffre : ["0"-"9"] >
| < entier : (<chiffre>)+ > 
	{ entierLu = Integer.parseInt(image.toString());
        }
| < #lettre: ["a"-"z"] >
| < ident : <lettre> (<lettre> | <chiffre>)* >
	{identLu =image.toString();	
	}
| < chaine : "\"" (~["\""])* "\"" | "'" (~["'"])* "'" >
	{ chaineLue = image.toString();
	 }
}

TOKEN :
{
	<CONST : "CONST">
	|	<VAR : "VAR">
	|	<PROGRAMME : "PROGRAMME">
	|	<FPROGRAMME : "FPROGRAMME">
}

/**************************************/
/********debut de la grammaire ********/
/**************************************/

void prog() : {}
{
	<PROGRAMME> <ident> bloc() <FPROGRAMME>
}

void bloc() : {}
{
   (declConst())* (declVar())* suiteExpr()
} 
void declConst() : {}
{
	<CONST> defConst() ("," defConst())* ";"
}

void defConst() : {}
{
	<ident> "=" valConst()
}

void valConst() : {}
{
	<entier> | <ident> | "VRAI" | "FAUX"
}

void declVar() :{}
{
	<VAR> type() <ident> ("," <ident>)* ";"
}

void type() : {}
{
	"ENTIER" | "BOOLEEN"
}

void suiteExpr() : {}
{
	expression() ( ";" (expression())?)*
}

void expression() : {}
{
	simpleExpr() (opRel() simpleExpr())?
}

void simpleExpr() : {} 
{
	terme() (opAdd() terme())*
}

void terme() : {}
{
	facteur() (opMult() facteur())*
}

void facteur() : {}
{
	opNeg() primaire() | primaire()
}
void primaire() : {}
{
	"(" expression() ")" | valeur() 
}
void valeur() : {}
{
	 <entier> | <ident> | "VRAI" | "FAUX"
}

void opRel() : {}
{
	">" | "<" | ">=" | "<=" | "=" | "<>"
}

void opAdd() : {}
{
	"+" | "-" | "OU"
}
void opMult() : {}
{
	"*" | "/" | "ET"
}
void opNeg() : {}
{
	"-" | "NON"
}


